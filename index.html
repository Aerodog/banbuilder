<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Banbuilder : Because its about $&amp;@%#$@$ time!" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Banbuilder - PHP curse word function and word list for application developers, moderators, etc.</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/snipe/banbuilder">View on GitHub</a>

          <h1 id="project_title">Banbuilder</h1>
          <h2 id="project_tagline">Because its about $&amp;@%#$@$ time!</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/snipe/banbuilder/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/snipe/banbuilder/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>BOO Censorship!</h3>
		<p>I hate censorship as much as anyone, but as a web application developer, 
		there are times when a banned-word list is necessary, especially if the 
		application or site is geared towards younger users or corporate environments.</p>
		
		<h3>How to Get It?</h3>
		<p>Just click on the tar.gz or .zip icons above to download the files. Or 
		if you prefer, you can clone the repo: </p>
		
		<pre><code>$ git clone git@github.com:snipe/banbuilder.git</code></pre>	


		<h3>Quickstart</h3>
		<p>There are basically only 2 files you need to start using this right away: <code>censor.functions.php</code> 
		and <code>wordlist-regex.php</code>. 
		The code below will include those two files, and return an array that contains your 
		original string (<code>$YOURSTRING</code> in the example below), and the cleaned string.</p>
		
<pre><code>include('wordlist-regex.php');
include('censor.function.php');
$censored = censorString(htmlentities(trim($YOURSTRING)), $badwords);
</code></pre>

		<p>After that, use <code>$censored['clean']</code> to refer to the cleaned version, and <code>$censored['orig']</code> to the original string.</p>
		
		<p>NOTE: If you don't use convert special characters to their HTML counterparts (for example, using <code>htmlentities()</code> 
		as in the example above), it will not match against special characters that are 
		sent through. </p>
		
		<p>For example, if a user submits &quot;&cent;unt&quot;, it will not be detected as a matching bad word if you 
		do not convert your string to special characters. The script is looking for <code>&amp;cent;</code>, NOT the literal <code>&cent;</code> symbol. 
		Just convert your string to HTML entities and you'll be fine. </p>
		
		<p>Also, this example doesn't use any user-submitted data escaping, since I did't want my example to 
		interfere with the data cleansing you might be doing. <strong>You must absolutely never send 
		unvalidated data through to your server or back out to the browser. NO exceptions.</strong></p>
		
		<h3>Important Note: No profanity filter is flawless </h3>
		<p>No banned-word list is going to be 
		flawless. A G-rated list will block out the word "screw", but there are certainly 
		legitimate uses for the word "screw". Also, the word "dick" might be banned, but many 
		men named Richard are called "Dick" as their nickname. You may need to edit your 
		list to suit your needs, removing some words from the banned-word list that you 
		feel are too restrictive.</p>
		
		
		<h3>What This Script Does</h3>
		<p>The script will take a 
		word or phrase and replace the words you put in the <code>$badwords</code> array and replace it with asterisks. 
		One asterisk for each letter of the word that's being replaced. 
		So &quot;shit&quot; turns into &quot;****&quot;, &quot;shitty&quot; turns into &quot;****ty&quot;, 
		etc. This script will honor the original case of the word being cleaned, and it is case-insensitive, 
		so it will not be tricked by MiXeD CaSE words.</p>
		
		<p>It will also look for common leetspeak-style substitutions, for example using foreign 
		characters or combinations of numbers and symbols to create text that looks the same - 
		like using pipe-parenthasis to create a "D", as |). I haven't finished all of those filters yet, 
		but I have a good start.  If you wish to twiddle those to add or remove, they can be found in the 
		<code>censor.function.php</code> file in the master branch, in the <code>$leet_replace array</code>.</p>
	
		
		<h3>What This Script Doesn't Do</h3>
		<p>Profanity filtering is actually pretty difficult, 
		if you want to do it REALLY right, since context is everything. 
		The word &quot;Dick&quot; can be a crude reference to male genitalia, or to the 
		nickname of a fellow named Richard. Context is the only way to tell the difference. 
		This database and PHP script isn't going to be able to determine context. </p>
		
		<p>If you put &quot;ass&quot; in your bad word array, legitimate words like 
		&quot;class&quot; will be turned into &quot;cl***&quot;, so choose your words wisely. This, 
		and a lack of context-understanding, is a limitation of profanity filters in general and it isn't unique to 
		this one. It is possible to create a whitelist of words on top of your blacklist, to specify 
		legitimate words that might have an exactly matching swear word within it (like "assign", "classy", etc), 
		but the creation and maintenance of that list would impractical, and running every string 
		through it would increase processing time considerably. </p>
		
		<p><strong>In general, profanity filters just don't work.</strong> At least not the way we want them to. </p>
		<blockquote>"Obscenity filtering is an enduring, maybe even timeless problem. 
		I'm doubtful it will ever be possible to solve this particular problem through 
		code alone. But it seems some companies and developers can't stop tilting at 
		that windmill. Which means you might want to think twice 
		before you move to Scunthorpe.<br> - 
		<a href="http://www.codinghorror.com/blog/2008/10/obscenity-filters-bad-idea-or-incredibly-intercoursing-bad-idea.html">Jeff Atwood</a> </blockquote>

		<p>And although this script makes a good effort at trying to block most attempts to get around filters by 
		using special characters, adding dots or dashes in between letters, etc - someone who is 
		really determined will find a way around whatever profanity filter you use. You should possibly consider 
		including a flag or report function into your application so that you can take punitive action against 
		people who are consistently trying to break the rules.
		</p>
		
			
		<h3>About This Project</h3>		
		<p>In the repo, over 800 naughty words are available in the following formats: </p>
		
		<ul>
			<li>SQL</li>
			<li>PHP Array</li>
			<li>CSV</li>
			<li>LaTex</li>
			<li>YML</li>
			<li>XML</li>
		</ul>

		<p>These databases were created with the assumption that you would not have access to regex. 
		If you do have the ability to use regex, I strongly recommend using the method described above, 
		as it's much more thorough and easier to maintain.


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">This project is maintained by <a href="https://github.com/snipe">snipe</a>, also known as <a href="http://twitter.com/snipeyhead">@snipeyhead</a> on the Twitters.</p>
        
      </footer>
    </div>

    

  </body>
</html>
